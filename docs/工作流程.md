# "五位一体"交付体系设计 - DeskLab 版

**核心理念**: 文档驱动 + 即时审计 + 面向对象分析

**适用项目**: DeskLab 个人工作台（Tauri + React + TypeScript）

**最新更新** (2026-01-10):
- ✅ 需求分析师：主动使用 AskUserQuestion 与用户沟通
- ✅ 架构师：Rust/TypeScript 双端设计，模块化分流
- ✅ 前端开发者：React + Tiptap + Excalidraw 组件开发
- ✅ 后端开发者：Rust Tauri Commands + SQLite 开发
- ✅ 审计师：使用 Sub-Agent 进行代码审查与测试验证

---

## 一、核心架构

```
文档驱动 (Single Source of Truth)
    ↓
docs/00_RTM.md (需求追踪表)
    ↓
┌─────────┬─────────┬─────────┬─────────┬─────────┐
│Analyst  │Architect│Frontend │Backend  │ Auditor │
│🔄 交互  │📋 分流  │⚛️ React │🦀 Rust  │🤖🧪审计 │
└─────────┴─────────┴─────────┴─────────┴─────────┘
    ↓         ↓         ↓         ↓         ↓
即时审计 (每阶段必须审计通过才能继续)
```

---

## 二、核心角色与职责

| 角色 | 技能名称 | 职责 | 核心特性 |
|:---|:---|:---|:---|
| 需求分析师 | `/requirements-analyst` | OORA 需求建模、RTM 维护 | 🔄 **主动 AskUserQuestion** 澄清需求 |
| 架构师 | `/architect` | 技术分流、模块划分、接口设计 | 📋 Rust/TS 边界划分，Tauri Command 设计 |
| 前端开发者 | `/frontend-dev` | React UI 组件开发 | ⚛️ Tiptap 编辑器、Excalidraw 画布集成 |
| 后端开发者 | `/backend-dev` | Rust Tauri 后端开发 | 🦀 SQLite 操作、文件处理、AI 集成 |
| 审计师 | `/code-reviewer` | 质量守门员 | 🤖🧪 **Sub-Agent** 代码审查与测试 |

---

## 三、强制工作流 (Sequential Flow)

```
需求建模 → 需求审计 → 技术设计 → 设计审计 → 增量开发 → 代码审计 → 验证测试 → 交付确认
   ↓          ↓          ↓          ↓          ↓          ↓          ↓          ↓
  OORA    AskUser    模块划分    接口契约   前后端     Sub-Agent   本地测试    问题记录
  建模     沟通      Rust/TS     审查       并行开发    审计       cargo test   & 跳过
```

**关键规则**:
- ❌ 未通过审计，**禁止**进入下一阶段
- ❌ **禁止**更改需求/方案/数据以绕过问题
- ✅ **必须**严格按照 RTM 中的 AC 执行
- ✅ 困难任务：重试2次 → 记录问题 → 跳过 → 继续下一个

---

## 四、文档驱动准则 (Single Source of Truth)

### 4.1 核心文档

```
docs/
├── 00_RTM.md              # 唯一真理来源（需求、变更、审计、问题）
├── 01_analysis/           # OORA 需求分析（主角、对象、流程）
│   └── [模块名].md
├── 02_design/             # 技术设计（模块、接口、数据结构）
│   └── [模块名].md
├── requirements.md        # 产品需求文档
├── tech-solution.md       # 技术方案
├── ooa-analysis.md        # 面向对象分析
└── ui/                    # UI 原型
    ├── index.html
    ├── file-center.html
    ├── canvas.html
    ├── settings.html
    └── search.html
```

### 4.2 RTM 核心结构

```markdown
# 需求追踪表 (RTM)

## 1. 需求列表
| ID | 模块 | 功能 | 优先级 | 审计状态 | 开发进度 | AC |

## 2. 变更日志
| CR-ID | 需求ID | 变更描述 | 影响面 | 状态 |

## 3. 审计流水
| 日期 | 对象 | 类型 | 结论 | 审计人 | 备注 |

## 4. 阻塞问题
| 问题ID | 需求(AC) | 问题描述 | 复现步骤 | 尝试方案 | 状态 |
```

### 4.3 工作原则

- **即时记录**: 每次操作后立即更新 RTM
- **变更闭环**: 所有变更必须有 CR-ID + 审计签字
- **问题透明**: 2次重试失败 → 记录到阻塞问题表 → 跳过 → 继续

---

## 五、DeskLab 模块划分

### 5.1 核心模块矩阵

| 模块 | 前端 (React/TS) | 后端 (Rust) | 优先级 |
|:---|:---|:---|:---|
| Editor | Tiptap 编辑器组件 | Markdown 文件读写 | P0 |
| TabManager | 多标签管理 | 文档状态持久化 | P0 |
| FileCenter | 文件列表/预览 UI | PDF/Word 解析、缩略图生成 | P1 |
| Search | 搜索 UI、结果展示 | SQLite FTS5 + sqlite-vec | P1 |
| AI | 对话面板、引用选择 | Provider Adapter、模型调用 | P1 |
| Canvas | Excalidraw 集成 | 画布文件存储 | P2 |
| Settings | 设置页面 | 配置持久化、密钥管理 | P2 |
| Export | 导出对话框 | PDF/Word/MD 生成 | P2 |

### 5.2 Tauri Command 边界

```
前端 (React)                    后端 (Rust Tauri)
     │                                │
     │── invoke("doc_read")  ────────>│ 读取 Markdown 文件
     │── invoke("doc_save")  ────────>│ 保存 Markdown 文件
     │── invoke("file_import") ──────>│ 导入文件、生成预览
     │── invoke("search_query") ─────>│ 全文/语义检索
     │── invoke("ai_chat") ──────────>│ AI 对话调用
     │── invoke("config_get/set") ───>│ 配置读写
     │<── events ────────────────────│ 文件变更通知
```

---

## 六、工具集成矩阵

| 工具 | 角色 | 场景 | 强制/建议 | 说明 |
|:---|:---|:---|:---|:---|
| AskUserQuestion | 需求分析师 | 需求不明确 | 🔴 **强制** | 禁止自行猜测 |
| Task (sub-agent) | 前端/后端开发者 | 复杂开发(3+文件) | 🟡 建议 | 节省上下文 |
| Task (sub-agent) | 审计师 | 深度代码审查 | 🟡 建议 | 并行处理 |
| cargo test | 后端开发者 | Rust 单元测试 | 🔴 **强制** | 每个 Command 必须有测试 |
| pnpm test | 前端开发者 | React 组件测试 | 🟡 建议 | 关键组件需测试 |

---

## 七、困难任务处理机制

### 7.1 重试策略

```
遇到问题
   ↓
第1次尝试: 分析原因，换方法（不改需求）
   ↓ 失败
第2次尝试: 深入分析，换实现（仍符合需求）
   ↓ 仍失败
记录问题 → 跳过当前任务 → 继续下一个
```

### 7.2 问题记录

**在 RTM 阻塞问题表中记录**:
- 问题ID: `ISSUE-[模块]-[序号]`
- 关联需求: `REQ-F-XXX (AC-N)`
- 问题描述: 简洁描述现象
- 复现步骤: 详细步骤列表
- 尝试方案: 已尝试的2种方法及结果
- 状态: `⏸️ 阻塞` | `🔄 处理中` | `✅ 已解决`

### 7.3 禁止事项

- ❌ 更改需求/方案/测试数据以绕过问题
- ❌ 无限循环尝试同一个问题
- ❌ 隐瞒问题继续下一步
- ✅ 部分完成 **优于** 完全阻塞

---

## 八、审计检查清单

### A. 需求审计 [Audit-REQ]
- [ ] AC 可测性：包含具体输入、操作、预期输出
- [ ] 业务建模：有流程图，识别了业务主角
- [ ] 影响分析：变更评估了影响面 [Rust/TS/UI/DB]
- [ ] 边界覆盖：覆盖正常和异常流程

### B. 设计审计 [Audit-DESIGN]
- [ ] 模块划分：Rust/TS 边界清晰
- [ ] Tauri Command：接口定义完整（参数/返回值/错误）
- [ ] 数据结构：SQLite 表结构合理
- [ ] 状态管理：React 状态设计合理
- [ ] 复用性：是否利用已有组件/模块

### C. 代码审计 [Audit-CODE]
- [ ] AC 覆盖：实现了 100% AC
- [ ] 类型安全：TypeScript 严格模式，Rust 无 unwrap
- [ ] 错误处理：前后端统一错误处理
- [ ] 性能考量：大文件处理、索引效率
- [ ] 代码规范：ESLint/Clippy 无警告

### D. 测试审计 [Audit-TEST]
- [ ] Rust 测试：cargo test 通过
- [ ] 前端测试：关键组件有测试
- [ ] 集成测试：Tauri Command 端到端可用
- [ ] 手动验收：UI 交互符合预期

---

## 九、技能配置要点

### 9.1 需求分析师 (requirements-analyst)

**核心能力**: OORA 建模 + 主动沟通

```
工作流程:
1. 读取 RTM 了解上下文
2. 🔄 使用 AskUserQuestion 澄清需求
   - 用户场景: 使用频率、数据规模
   - 功能边界: 必须/可选/延后
   - 交互细节: UI 行为、快捷键
3. OORA 建模: 主角 → 对象 → 流程
4. 输出文档: docs/01_analysis/[模块].md
5. 更新 RTM: 登记需求，设置状态为 ⏳ 待审计
```

### 9.2 架构师 (architect)

**核心能力**: 模块划分 + Tauri Command 设计

```
分流策略:
- [Frontend]: UI 组件、状态管理、用户交互
- [Backend]: 文件 I/O、数据库、AI 调用、计算密集任务
- [Shared]: TypeScript 类型定义（前后端共享）

设计产出:
- 模块结构图
- Tauri Command 接口定义
- SQLite 表结构
- React 组件树
- 状态流转图
```

### 9.3 前端开发者 (frontend-dev)

**核心能力**: React + Tiptap + Excalidraw

```
技术栈:
- React 18 + TypeScript
- Vite 构建
- Tiptap 编辑器
- Excalidraw 画布
- Zustand/Jotai 状态管理（待定）

开发规范:
- 使用函数组件 + Hooks
- 类型严格，禁止 any
- 组件职责单一
- 使用 @tauri-apps/api 调用后端
```

### 9.4 后端开发者 (backend-dev)

**核心能力**: Rust + Tauri + SQLite

```
技术栈:
- Rust + Tauri 2
- SQLite (rusqlite)
- pdf.js 绑定 / mammoth 调用
- ONNX Runtime (Embedding)
- reqwest (AI API 调用)

开发规范:
- 使用 Result<T, E> 错误处理
- 禁止 unwrap()，使用 ? 或 expect 带说明
- Command 必须有单元测试
- 文件操作使用异步
```

### 9.5 审计师 (code-reviewer)

**核心能力**: 质量守门 + Sub-Agent 审查

```
审计流程:
1. 读取 RTM 确认 AC
2. 代码审查:
   - 类型安全
   - 错误处理
   - 性能风险
3. 测试验证:
   - cargo test
   - pnpm test
   - 手动 UI 验收
4. 失败处理:
   - 第1次: 指出问题，等待修复
   - 第2次: 确认问题，记录 ISSUE
   - 仍失败: 跳过，继续下一个 AC
```

---

## 十、最佳实践

1. **先审计后推进**: 每阶段必须审计通过
2. **RTM 即时更新**: 完成操作立即记录
3. **增量优于覆盖**: 使用 Edit 而非 Write
4. **类型先行**: 先定义 TypeScript/Rust 类型，再实现
5. **AC 要可测**: 具体、可衡量、可验证
6. 🔄 **主动沟通**: 需求不明确用 AskUserQuestion
7. 🤖 **合理 Sub-Agent**: 复杂任务节省上下文
8. 🦀 **Rust 测试**: 每个 Command 必须有测试
9. ⚛️ **组件复用**: 优先使用/扩展已有组件
10. ⚠️ **2次重试**: 失败后记录问题，跳过继续

---

## 十一、常见问题 (FAQ)

**Q1: 需求不明确时怎么办？**
A: **必须**使用 AskUserQuestion，提供选项让用户选择，**禁止**自行猜测。

**Q2: 功能应该放前端还是后端？**
A:
- 前端：UI 渲染、用户交互、轻量计算
- 后端：文件 I/O、数据库、AI 调用、CPU 密集计算

**Q3: 什么时候使用 sub-agent？**
A: 复杂开发（3+文件、300+行）、深度审计时**建议**使用，节省上下文。

**Q4: 开发/测试遇到困难怎么办？**
A: 重试2次 → 仍失败 → 记录到 RTM 阻塞问题表 → 跳过 → 继续下一个任务。**禁止**原地打转。

**Q5: Tauri Command 如何定义？**
A: 在 `src-tauri/src/commands/` 下创建模块，使用 `#[tauri::command]` 宏，在 `main.rs` 注册。

**Q6: 前后端类型如何共享？**
A: 后端定义 Rust struct，使用 `ts-rs` 或手动维护对应的 TypeScript interface。

---

## 十二、技能调用示例

```bash
# 需求分析（会主动询问）
/requirements-analyst 分析编辑器自动保存需求

# 架构设计
/architect 设计文件中心模块

# 前端开发
/frontend-dev 实现文件预览组件

# 后端开发
/backend-dev 实现 PDF 文本抽取 Command

# 代码审计
/code-reviewer 审计 REQ-F-007 PDF 预览功能
```

---

## 十三、MVP 开发顺序

按技术方案建议顺序：

| 阶段 | 模块 | 前端任务 | 后端任务 |
|:---|:---|:---|:---|
| 1 | Editor | Tiptap 集成、工具栏 | Markdown 读写、自动保存 |
| 2 | TabManager | 标签栏 UI | 标签状态持久化 |
| 3 | FileCenter | 文件列表、预览 UI | PDF/docx 解析、缩略图 |
| 4 | Search | 搜索 UI、过滤器 | FTS5 + sqlite-vec |
| 5 | AI | 对话面板、引用 | Provider Adapter |
| 6 | Canvas | Excalidraw 集成 | 画布文件存储 |
| 7 | Export | 导出对话框 | PDF/Word 生成 |

---

**文档版本**: v1.0
**最后更新**: 2026-01-10
**核心理念**: 文档驱动 + 即时审计 + 面向对象分析
**适用项目**: DeskLab 个人工作台
